{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GitHub Action reusable workflows \u00b6 This repository contains reusable workflows for GitHub Actions. They are mainly for usage with modern Python package repositories. Available workflows \u00b6 The callable, reusable workflows available from this repository are described in detail in this documentation under the \"Workflows\" section. General usage \u00b6 See the GitHub Docs on the topic of calling a reusable workflow to understand how one can incoporate one of these workflows in your workflow. Note Workflow-level set env context variables cannot be used when setting input values for the called workflow. See the GitHub documentation for more information on the env context. Under the \"Workflows\" section for each available workflow, a usage example will be given. License & copyright \u00b6 This repository licensed under the MIT LICENSE with copyright \u00a9 2022 Casper Welzel Andersen ( CasperWA ).","title":"Home"},{"location":"#github-action-reusable-workflows","text":"This repository contains reusable workflows for GitHub Actions. They are mainly for usage with modern Python package repositories.","title":"GitHub Action reusable workflows"},{"location":"#available-workflows","text":"The callable, reusable workflows available from this repository are described in detail in this documentation under the \"Workflows\" section.","title":"Available workflows"},{"location":"#general-usage","text":"See the GitHub Docs on the topic of calling a reusable workflow to understand how one can incoporate one of these workflows in your workflow. Note Workflow-level set env context variables cannot be used when setting input values for the called workflow. See the GitHub documentation for more information on the env context. Under the \"Workflows\" section for each available workflow, a usage example will be given.","title":"General usage"},{"location":"#license-copyright","text":"This repository licensed under the MIT LICENSE with copyright \u00a9 2022 Casper Welzel Andersen ( CasperWA ).","title":"License &amp; copyright"},{"location":"CHANGELOG/","text":"Changelog \u00b6 v1.0.0 (2022-07-06) \u00b6 Full Changelog Implemented enhancements: Use proper option for changelog generator instead of moving file afterwards #13 Update CHANGELOG with unreleased stuff when updating default branch #11 Update to new repo name #8 Allow testing/debugging CI/CD workflow #6 Make \"FIRST_RELEASE\" bool more robust #3 Fixed bugs: Exclude tags from PREVIOUS_VERSION in release workflow #17 Update local workflow for updated CI/CD workflow #12 Fix links for various \"default\" PR bodies and tag messages #9 API Reference creation not working #7 Ensure the permanent dependencies branch is always updated #4 Closed issues: Update documentation with new inputs for CI/CD workflow #14 Workflow overview in documentation #5 Merged pull requests: Update repo and workflow title names #10 ( CasperWA ) v0.1.0 (2022-07-05) \u00b6 Full Changelog Merged pull requests: New workflow triggering changes with new default branch changes #1 ( CasperWA ) * This Changelog was automatically generated by github_changelog_generator","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#v100-2022-07-06","text":"Full Changelog Implemented enhancements: Use proper option for changelog generator instead of moving file afterwards #13 Update CHANGELOG with unreleased stuff when updating default branch #11 Update to new repo name #8 Allow testing/debugging CI/CD workflow #6 Make \"FIRST_RELEASE\" bool more robust #3 Fixed bugs: Exclude tags from PREVIOUS_VERSION in release workflow #17 Update local workflow for updated CI/CD workflow #12 Fix links for various \"default\" PR bodies and tag messages #9 API Reference creation not working #7 Ensure the permanent dependencies branch is always updated #4 Closed issues: Update documentation with new inputs for CI/CD workflow #14 Workflow overview in documentation #5 Merged pull requests: Update repo and workflow title names #10 ( CasperWA )","title":"v1.0.0 (2022-07-06)"},{"location":"CHANGELOG/#v010-2022-07-05","text":"Full Changelog Merged pull requests: New workflow triggering changes with new default branch changes #1 ( CasperWA ) * This Changelog was automatically generated by github_changelog_generator","title":"v0.1.0 (2022-07-05)"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2022 Casper Welzel Andersen Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"python/tasks/","text":"Invoke tasks \u00b6 Repository management tasks powered by invoke . More information on invoke can be found at pyinvoke.org . create_api_reference_docs ( context , package_dir , pre_clean = False , pre_commit = False , repo_folder = 'main' , docs_folder = 'docs' , unwanted_dirs = '__pycache__' , unwanted_files = '__init__.py' , full_docs_dirs = '' , debug = False ) \u00b6 Create the Python API Reference in the documentation. Source code in ci-cd/tasks.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 @task ( help = { \"package-dir\" : ( \"Relative path to package dir from the repository root, \" \"e.g. 'src/my_package'.\" ), \"pre-clean\" : \"Remove the 'api_reference' sub directory prior to (re)creation.\" , \"pre-commit\" : \"Return a non-zero error code if changes were made.\" , \"repo-folder\" : ( \"The folder name of the repository, wherein the package dir is located. \" \"This defaults to 'main', as this will be used in the callable workflows.\" ), \"docs-folder\" : ( \"The folder name for the documentation root folder. \" \"This defaults to 'docs'.\" ), \"unwanted-dirs\" : ( \"Comma-separated list of directories to avoid including in the Python API \" \"reference documentation. Note, only directory names, not paths, may be \" \"included. Note, all folders and their contents with these names will be \" \"excluded. Defaults to '__pycache__'.\" ), \"unwanted-files\" : ( \"Comma-separated list of files to avoid including the Python API reference\" \" documentation. Note, only full file names, not paths, may be included, \" \"i.e., filename + file extension. Note, all files with these names will \" \"be excluded. Defaults to '__init__.py'.\" ), \"full-docs-dirs\" : ( \"Comma-separated list of directories in which to include everything - even\" \" those without documentation strings. This may be useful for a module \" \"full of data models or to ensure all class attributes are listed.\" ), \"debug\" : \"Whether or not to print debug statements.\" , } ) def create_api_reference_docs ( # pylint: disable=too-many-locals,too-many-branches,too-many-statements,line-too-long context , package_dir , pre_clean = False , pre_commit = False , repo_folder = \"main\" , docs_folder = \"docs\" , unwanted_dirs = \"__pycache__\" , unwanted_files = \"__init__.py\" , full_docs_dirs = \"\" , debug = False , ): \"\"\"Create the Python API Reference in the documentation.\"\"\" import os import shutil def write_file ( full_path : Path , content : str ) -> None : \"\"\"Write file with `content` to `full_path`\"\"\" if full_path . exists (): cached_content = full_path . read_text ( encoding = \"utf8\" ) if content == cached_content : del cached_content return del cached_content full_path . write_text ( content , encoding = \"utf8\" ) package_dir : Path = REPO_PARENT_DIR / repo_folder / package_dir docs_api_ref_dir : Path = ( REPO_PARENT_DIR / repo_folder / docs_folder / \"api_reference\" ) if debug : print ( \"package_dir:\" , package_dir , flush = True ) print ( \"docs_api_ref_dir:\" , docs_api_ref_dir , flush = True ) print ( \"unwanted_dirs + unwanted_files:\" , unwanted_dirs + unwanted_files , flush = True , ) if \"/\" in unwanted_dirs + unwanted_files : sys . exit ( \"Unwanted directories and files may NOT be paths. A forward slash (/) was \" f \"found in them. Given \\n\\n --unwanted-dirs= { unwanted_dirs } , \\n \" f \"--unwanted-files= { unwanted_files } \" ) unwanted_subdirs : list [ str ] = unwanted_dirs . split ( \",\" ) unwanted_subfiles : list [ str ] = unwanted_files . split ( \",\" ) no_docstring_dirs : list [ str ] = full_docs_dirs . split ( \",\" ) if debug : print ( \"unwanted_subdirs:\" , unwanted_subdirs , flush = True ) print ( \"unwanted_subfiles:\" , unwanted_subfiles , flush = True ) print ( \"no_docstring_dirs:\" , no_docstring_dirs , flush = True ) pages_template = 'title: \" {name} \" \\n ' md_template = \"# {name} \\n\\n ::: {py_path} \\n \" no_docstring_template = ( md_template + f \" { ' ' * 4 } options: \\n { ' ' * 6 } show_if_no_docstring: true \\n \" ) if docs_api_ref_dir . exists () and pre_clean : if debug : print ( f \"Removing { docs_api_ref_dir } \" , flush = True ) shutil . rmtree ( docs_api_ref_dir , ignore_errors = True ) if docs_api_ref_dir . exists (): sys . exit ( f \" { docs_api_ref_dir } should have been removed!\" ) docs_api_ref_dir . mkdir ( exist_ok = True ) if debug : print ( f \"Writing file: { docs_api_ref_dir / '.pages' } \" , flush = True ) write_file ( full_path = docs_api_ref_dir / \".pages\" , content = pages_template . format ( name = \"API Reference\" ), ) for dirpath , dirnames , filenames in os . walk ( package_dir ): for unwanted_dir in unwanted_subdirs : if debug : print ( \"unwanted_dir:\" , unwanted_dir , flush = True ) print ( \"dirnames:\" , dirnames , flush = True ) if unwanted_dir in dirnames : # Avoid walking into or through unwanted directories dirnames . remove ( unwanted_dir ) relpath = Path ( dirpath ) . relative_to ( package_dir ) abspath = ( package_dir / relpath ) . resolve () if debug : print ( \"relpath:\" , relpath , flush = True ) print ( \"abspath:\" , abspath , flush = True ) if not ( abspath / \"__init__.py\" ) . exists (): # Avoid paths that are not included in the public Python API print ( \"does not exist:\" , abspath / \"__init__.py\" , flush = True ) continue # Create `.pages` docs_sub_dir = docs_api_ref_dir / relpath docs_sub_dir . mkdir ( exist_ok = True ) if debug : print ( \"docs_sub_dir:\" , docs_sub_dir , flush = True ) if str ( relpath ) != \".\" : if debug : print ( f \"Writing file: { docs_sub_dir / '.pages' } \" , flush = True ) write_file ( full_path = docs_sub_dir / \".pages\" , content = pages_template . format ( name = str ( relpath ) . rsplit ( \"/\" , maxsplit = 1 )[ - 1 ] ), ) # Create markdown files for filename in filenames : if re . match ( r \".*\\.py$\" , filename ) is None or filename in unwanted_subfiles : # Not a Python file: We don't care about it! # Or filename is in the tuple of unwanted files: # We don't want it! if debug : print ( f \" { filename } is not a Python file or is in unwanted_subfiles. Skipping it.\" , flush = True , ) continue basename = filename [: - len ( \".py\" )] py_path = ( f \" { package_dir . name } / { relpath } / { basename } \" . replace ( \"/\" , \".\" ) if str ( relpath ) != \".\" else f \" { package_dir . name } / { basename } \" . replace ( \"/\" , \".\" ) ) md_filename = filename . replace ( \".py\" , \".md\" ) if debug : print ( \"basename:\" , basename , flush = True ) print ( \"py_path:\" , py_path , flush = True ) print ( \"md_filename:\" , md_filename , flush = True ) # For special folders we want to include EVERYTHING, even if it doesn't # have a doc-string template = ( no_docstring_template if str ( relpath ) in no_docstring_dirs else md_template ) if debug : print ( \"template:\" , template , flush = True ) print ( f \"Writing file: { docs_sub_dir / md_filename } \" , flush = True ) write_file ( full_path = docs_sub_dir / md_filename , content = template . format ( name = basename , py_path = py_path ), ) if pre_commit : # Check if there have been any changes. # List changes if yes. if TYPE_CHECKING : # pragma: no cover context : \"Context\" = context # NOTE: grep returns an exit code of 1 if it doesn't find anything # (which will be good in this case). # Concerning the weird last grep command see: # http://manpages.ubuntu.com/manpages/precise/en/man1/git-status.1.html result : \"Result\" = context . run ( f 'git -C \" { REPO_PARENT_DIR / repo_folder } \" status --porcelain ' f \" { docs_api_ref_dir . relative_to ( REPO_PARENT_DIR / repo_folder ) } | \" \"grep -E '^[? MARC][?MD]' || exit 0\" , hide = True , ) if result . stdout : sys . exit ( \"The following files have been changed/added, please stage \" f \"them: \\n\\n { result . stdout } \" ) create_docs_index ( _ , repo_folder = 'main' , docs_folder = 'docs' , replacements = '' , replacements_separator = '|' , internal_separator = ',' ) \u00b6 Create the documentation index page from README.md. Source code in ci-cd/tasks.py 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 @task ( help = { \"repo-folder\" : ( \"The folder name of the repository, wherein the package dir is located. \" \"This defaults to 'main', as this will be used in the callable workflows.\" ), \"docs-folder\" : ( \"The folder name for the documentation root folder. \" \"This defaults to 'docs'.\" ), \"replacements\" : ( \"List of replacements (mappings) to be performed on README.md when \" \"creating the documentation's landing page (index.md). This list ALWAYS \" \"includes replacing '{docs-folder}/' with an empty string to correct \" \"relative links.\" ), \"replacements-separator\" : ( \"String to separate replacement mappings from the 'replacements' input. \" \"Defaults to a pipe (|).\" ), \"internal-separator\" : ( \"String to separate a single mapping's 'old' to 'new' statement. \" \"Defaults to a comma (,).\" ), } ) def create_docs_index ( _ , repo_folder = \"main\" , docs_folder = \"docs\" , replacements = \"\" , replacements_separator = \"|\" , internal_separator = \",\" , ): \"\"\"Create the documentation index page from README.md.\"\"\" readme : Path = REPO_PARENT_DIR / repo_folder / \"README.md\" docs_index : Path = REPO_PARENT_DIR / repo_folder / docs_folder / \"index.md\" content = readme . read_text ( encoding = \"utf8\" ) replacement_mapping = [( f \" { docs_folder } /\" , \"\" )] for replacement in replacements . split ( replacements_separator ): new_replacement_map = replacement . split ( internal_separator ) if len ( new_replacement_map ) != 2 : sys . exit ( \"A single replacement must only include an 'old' and 'new' part, \" \"i.e., be of exactly length 2 when split by the \" \"'--internal-separator'. The following replacement did not fulfill \" f \"this requirement: { replacement !r} \\n \" f \"--internal-separator= { internal_separator !r} \\n \" f \"--replacements-separator= { replacements_separator !r} \" ) replacement_mapping . append ( tuple ( new_replacement_map )) for old , new in replacement_mapping : content = content . replace ( old , new ) docs_index . write_text ( content , encoding = \"utf8\" ) setver ( _ , package_dir , version , repo_folder = 'main' ) \u00b6 Sets the specified version of specified Python package. Source code in ci-cd/tasks.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @task ( help = { \"version\" : \"Version to set.\" , \"package-dir\" : ( \"Relative path to package dir from the repository root, \" \"e.g. 'src/my_package'.\" ), \"repo-folder\" : ( \"The folder name of the repository, wherein the package dir is located. \" \"This defaults to 'main', as this will be used in the callable workflows.\" ), } ) def setver ( _ , package_dir , version , repo_folder = \"main\" ): \"\"\"Sets the specified version of specified Python package.\"\"\" match = re . fullmatch ( ( r \"v?(?P<version>[0-9]+(\\.[0-9]+) {2} \" # Major.Minor.Patch r \"(-[0-9A-Za-z-]+(\\.[0-9A-Za-z-]+)*)?\" # pre-release r \"(\\+[0-9A-Za-z-]+(\\.[0-9A-Za-z-]+)*)?)\" # build metadata ), version , ) if not match : sys . exit ( \"Error: Please specify version as \" \"'Major.Minor.Patch(-Pre-Release+Build Metadata)' or \" \"'vMajor.Minor.Patch(-Pre-Release+Build Metadata)'\" ) version = match . group ( \"version\" ) init_file : Path = REPO_PARENT_DIR / repo_folder / package_dir / \"__init__.py\" if not init_file . exists (): sys . exit ( \"Error: Could not find the Python package's root '__init__.py' file at: \" f \" { init_file } \" ) update_file ( init_file , ( r '__version__ *= *( \\' |\").*( \\' |\")' , f '__version__ = \" { version } \"' ), ) print ( f \"Bumped version for { package_dir } to { version } .\" ) update_deps ( context , repo_folder = 'main' , fail_fast = False ) \u00b6 Update dependencies in specified Python package's pyproject.toml . Source code in ci-cd/tasks.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 @task ( help = { \"fail-fast\" : ( \"Fail immediately if an error occurs. Otherwise, print and ignore all \" \"non-critical errors.\" ), \"repo-folder\" : ( \"The folder name of the repository, wherein the package dir is located. \" \"This defaults to 'main', as this will be used in the callable workflows.\" ), } ) def update_deps ( # pylint: disable=too-many-branches,too-many-locals,too-many-statements context , repo_folder = \"main\" , fail_fast = False ): \"\"\"Update dependencies in specified Python package's `pyproject.toml`.\"\"\" import tomlkit if TYPE_CHECKING : # pragma: no cover context : \"Context\" = context pyproject_path = REPO_PARENT_DIR / repo_folder / \"pyproject.toml\" if not pyproject_path . exists (): sys . exit ( \"Error: Could not find the Python package repository's 'pyproject.toml' \" f \"file at: { pyproject_path } \" ) pyproject = tomlkit . loads ( pyproject_path . read_bytes ()) py_version = re . match ( r \"^.*(?P<version>3\\.[0-9]+)$\" , pyproject . get ( \"project\" , {}) . get ( \"requires-python\" , \"\" ), ) . group ( \"version\" ) already_handled_packages = set () updated_packages = {} dependencies = pyproject . get ( \"project\" , {}) . get ( \"dependencies\" , []) for optional_deps in ( pyproject . get ( \"project\" , {}) . get ( \"optional-dependencies\" , {}) . values () ): dependencies . extend ( optional_deps ) for line in dependencies : match = re . match ( r \"^(?P<full_dependency>(?P<package>[a-zA-Z0-9-_]+)\\S*) \" r \"(?P<operator>>|<|<=|>=|==|!=|~=)\" r \"(?P<version>[0-9]+(?:\\.[0-9]+){0,2})\" r \"(?P<extra_op_ver>(?:,(?:>|<|<=|>=|==|!=|~=)\" r \"[0-9]+(?:\\.[0-9]+){0,2})*)$\" , line , ) if match is None : msg = f \"Could not parse package, operator, and version for line: \\n { line } \" if fail_fast : sys . exit ( msg ) print ( msg ) full_dependency_name = match . group ( \"full_dependency\" ) package = match . group ( \"package\" ) operator = match . group ( \"operator\" ) version = match . group ( \"version\" ) extra_op_ver = match . group ( \"extra_op_ver\" ) # Skip package if already handled if package in already_handled_packages : continue # Check version from PyPI's online package index out : \"Result\" = context . run ( f \"pip index versions --python-version { py_version } { package } \" , hide = True , ) package_latest_version_line = out . stdout . split ( sep = \" \\n \" , maxsplit = 1 )[ 0 ] match = re . match ( r \"(?P<package>[a-zA-Z0-9-_]+) \\((?P<version>[0-9]+(?:\\.[0-9]+){0,2})\\)\" , package_latest_version_line , ) if match is None : msg = ( \"Could not parse package and version from 'pip index versions' output \" f \"for line: \\n { package_latest_version_line } \" ) if fail_fast : sys . exit ( msg ) print ( msg ) # Sanity check if package != match . group ( \"package\" ): msg = ( f \"Package name parsed from pyproject.toml ( { package !r} ) does not match\" \" the name returned from 'pip index versions': \" f \" { match . group ( 'package' ) !r} \" ) if fail_fast : sys . exit ( msg ) print ( msg ) latest_version = match . group ( \"version\" ) . split ( \".\" ) for index , version_part in enumerate ( version . split ( \".\" )): if version_part != latest_version [ index ]: break else : already_handled_packages . add ( package ) continue # Update pyproject.toml updated_version = \".\" . join ( latest_version [: len ( version . split ( \".\" ))]) escaped_full_dependency_name = full_dependency_name . replace ( \"[\" , \"\\[\" # pylint: disable=anomalous-backslash-in-string ) . replace ( \"]\" , \"\\]\" # pylint: disable=anomalous-backslash-in-string ) update_file ( pyproject_path , ( rf '\" { escaped_full_dependency_name } { operator } .*\"' , f '\" { full_dependency_name } { operator }{ updated_version } ' f ' { extra_op_ver if extra_op_ver else \"\" } \"' , ), ) already_handled_packages . add ( package ) updated_packages [ full_dependency_name ] = f \" { operator }{ updated_version } \" if updated_packages : print ( \"Successfully updated the following dependencies: \\n \" + \" \\n \" . join ( f \" { package } ( { version }{ extra_op_ver if extra_op_ver else '' } )\" for package , version in updated_packages . items () ) + \" \\n \" ) else : print ( \"No dependency updates available.\" ) update_file ( filename , sub_line , strip = None ) \u00b6 Utility function for tasks to read, update, and write files Source code in ci-cd/tasks.py 21 22 23 24 25 26 27 def update_file ( filename : Path , sub_line : \"Tuple[str, str]\" , strip : str = None ) -> None : \"\"\"Utility function for tasks to read, update, and write files\"\"\" lines = [ re . sub ( sub_line [ 0 ], sub_line [ 1 ], line . rstrip ( strip )) for line in filename . read_text ( encoding = \"utf8\" ) . splitlines () ] filename . write_text ( \" \\n \" . join ( lines ) + \" \\n \" , encoding = \"utf8\" )","title":"Invoke tasks"},{"location":"python/tasks/#invoke-tasks","text":"Repository management tasks powered by invoke . More information on invoke can be found at pyinvoke.org .","title":"Invoke tasks"},{"location":"python/tasks/#tasks.create_api_reference_docs","text":"Create the Python API Reference in the documentation. Source code in ci-cd/tasks.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 @task ( help = { \"package-dir\" : ( \"Relative path to package dir from the repository root, \" \"e.g. 'src/my_package'.\" ), \"pre-clean\" : \"Remove the 'api_reference' sub directory prior to (re)creation.\" , \"pre-commit\" : \"Return a non-zero error code if changes were made.\" , \"repo-folder\" : ( \"The folder name of the repository, wherein the package dir is located. \" \"This defaults to 'main', as this will be used in the callable workflows.\" ), \"docs-folder\" : ( \"The folder name for the documentation root folder. \" \"This defaults to 'docs'.\" ), \"unwanted-dirs\" : ( \"Comma-separated list of directories to avoid including in the Python API \" \"reference documentation. Note, only directory names, not paths, may be \" \"included. Note, all folders and their contents with these names will be \" \"excluded. Defaults to '__pycache__'.\" ), \"unwanted-files\" : ( \"Comma-separated list of files to avoid including the Python API reference\" \" documentation. Note, only full file names, not paths, may be included, \" \"i.e., filename + file extension. Note, all files with these names will \" \"be excluded. Defaults to '__init__.py'.\" ), \"full-docs-dirs\" : ( \"Comma-separated list of directories in which to include everything - even\" \" those without documentation strings. This may be useful for a module \" \"full of data models or to ensure all class attributes are listed.\" ), \"debug\" : \"Whether or not to print debug statements.\" , } ) def create_api_reference_docs ( # pylint: disable=too-many-locals,too-many-branches,too-many-statements,line-too-long context , package_dir , pre_clean = False , pre_commit = False , repo_folder = \"main\" , docs_folder = \"docs\" , unwanted_dirs = \"__pycache__\" , unwanted_files = \"__init__.py\" , full_docs_dirs = \"\" , debug = False , ): \"\"\"Create the Python API Reference in the documentation.\"\"\" import os import shutil def write_file ( full_path : Path , content : str ) -> None : \"\"\"Write file with `content` to `full_path`\"\"\" if full_path . exists (): cached_content = full_path . read_text ( encoding = \"utf8\" ) if content == cached_content : del cached_content return del cached_content full_path . write_text ( content , encoding = \"utf8\" ) package_dir : Path = REPO_PARENT_DIR / repo_folder / package_dir docs_api_ref_dir : Path = ( REPO_PARENT_DIR / repo_folder / docs_folder / \"api_reference\" ) if debug : print ( \"package_dir:\" , package_dir , flush = True ) print ( \"docs_api_ref_dir:\" , docs_api_ref_dir , flush = True ) print ( \"unwanted_dirs + unwanted_files:\" , unwanted_dirs + unwanted_files , flush = True , ) if \"/\" in unwanted_dirs + unwanted_files : sys . exit ( \"Unwanted directories and files may NOT be paths. A forward slash (/) was \" f \"found in them. Given \\n\\n --unwanted-dirs= { unwanted_dirs } , \\n \" f \"--unwanted-files= { unwanted_files } \" ) unwanted_subdirs : list [ str ] = unwanted_dirs . split ( \",\" ) unwanted_subfiles : list [ str ] = unwanted_files . split ( \",\" ) no_docstring_dirs : list [ str ] = full_docs_dirs . split ( \",\" ) if debug : print ( \"unwanted_subdirs:\" , unwanted_subdirs , flush = True ) print ( \"unwanted_subfiles:\" , unwanted_subfiles , flush = True ) print ( \"no_docstring_dirs:\" , no_docstring_dirs , flush = True ) pages_template = 'title: \" {name} \" \\n ' md_template = \"# {name} \\n\\n ::: {py_path} \\n \" no_docstring_template = ( md_template + f \" { ' ' * 4 } options: \\n { ' ' * 6 } show_if_no_docstring: true \\n \" ) if docs_api_ref_dir . exists () and pre_clean : if debug : print ( f \"Removing { docs_api_ref_dir } \" , flush = True ) shutil . rmtree ( docs_api_ref_dir , ignore_errors = True ) if docs_api_ref_dir . exists (): sys . exit ( f \" { docs_api_ref_dir } should have been removed!\" ) docs_api_ref_dir . mkdir ( exist_ok = True ) if debug : print ( f \"Writing file: { docs_api_ref_dir / '.pages' } \" , flush = True ) write_file ( full_path = docs_api_ref_dir / \".pages\" , content = pages_template . format ( name = \"API Reference\" ), ) for dirpath , dirnames , filenames in os . walk ( package_dir ): for unwanted_dir in unwanted_subdirs : if debug : print ( \"unwanted_dir:\" , unwanted_dir , flush = True ) print ( \"dirnames:\" , dirnames , flush = True ) if unwanted_dir in dirnames : # Avoid walking into or through unwanted directories dirnames . remove ( unwanted_dir ) relpath = Path ( dirpath ) . relative_to ( package_dir ) abspath = ( package_dir / relpath ) . resolve () if debug : print ( \"relpath:\" , relpath , flush = True ) print ( \"abspath:\" , abspath , flush = True ) if not ( abspath / \"__init__.py\" ) . exists (): # Avoid paths that are not included in the public Python API print ( \"does not exist:\" , abspath / \"__init__.py\" , flush = True ) continue # Create `.pages` docs_sub_dir = docs_api_ref_dir / relpath docs_sub_dir . mkdir ( exist_ok = True ) if debug : print ( \"docs_sub_dir:\" , docs_sub_dir , flush = True ) if str ( relpath ) != \".\" : if debug : print ( f \"Writing file: { docs_sub_dir / '.pages' } \" , flush = True ) write_file ( full_path = docs_sub_dir / \".pages\" , content = pages_template . format ( name = str ( relpath ) . rsplit ( \"/\" , maxsplit = 1 )[ - 1 ] ), ) # Create markdown files for filename in filenames : if re . match ( r \".*\\.py$\" , filename ) is None or filename in unwanted_subfiles : # Not a Python file: We don't care about it! # Or filename is in the tuple of unwanted files: # We don't want it! if debug : print ( f \" { filename } is not a Python file or is in unwanted_subfiles. Skipping it.\" , flush = True , ) continue basename = filename [: - len ( \".py\" )] py_path = ( f \" { package_dir . name } / { relpath } / { basename } \" . replace ( \"/\" , \".\" ) if str ( relpath ) != \".\" else f \" { package_dir . name } / { basename } \" . replace ( \"/\" , \".\" ) ) md_filename = filename . replace ( \".py\" , \".md\" ) if debug : print ( \"basename:\" , basename , flush = True ) print ( \"py_path:\" , py_path , flush = True ) print ( \"md_filename:\" , md_filename , flush = True ) # For special folders we want to include EVERYTHING, even if it doesn't # have a doc-string template = ( no_docstring_template if str ( relpath ) in no_docstring_dirs else md_template ) if debug : print ( \"template:\" , template , flush = True ) print ( f \"Writing file: { docs_sub_dir / md_filename } \" , flush = True ) write_file ( full_path = docs_sub_dir / md_filename , content = template . format ( name = basename , py_path = py_path ), ) if pre_commit : # Check if there have been any changes. # List changes if yes. if TYPE_CHECKING : # pragma: no cover context : \"Context\" = context # NOTE: grep returns an exit code of 1 if it doesn't find anything # (which will be good in this case). # Concerning the weird last grep command see: # http://manpages.ubuntu.com/manpages/precise/en/man1/git-status.1.html result : \"Result\" = context . run ( f 'git -C \" { REPO_PARENT_DIR / repo_folder } \" status --porcelain ' f \" { docs_api_ref_dir . relative_to ( REPO_PARENT_DIR / repo_folder ) } | \" \"grep -E '^[? MARC][?MD]' || exit 0\" , hide = True , ) if result . stdout : sys . exit ( \"The following files have been changed/added, please stage \" f \"them: \\n\\n { result . stdout } \" )","title":"create_api_reference_docs()"},{"location":"python/tasks/#tasks.create_docs_index","text":"Create the documentation index page from README.md. Source code in ci-cd/tasks.py 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 @task ( help = { \"repo-folder\" : ( \"The folder name of the repository, wherein the package dir is located. \" \"This defaults to 'main', as this will be used in the callable workflows.\" ), \"docs-folder\" : ( \"The folder name for the documentation root folder. \" \"This defaults to 'docs'.\" ), \"replacements\" : ( \"List of replacements (mappings) to be performed on README.md when \" \"creating the documentation's landing page (index.md). This list ALWAYS \" \"includes replacing '{docs-folder}/' with an empty string to correct \" \"relative links.\" ), \"replacements-separator\" : ( \"String to separate replacement mappings from the 'replacements' input. \" \"Defaults to a pipe (|).\" ), \"internal-separator\" : ( \"String to separate a single mapping's 'old' to 'new' statement. \" \"Defaults to a comma (,).\" ), } ) def create_docs_index ( _ , repo_folder = \"main\" , docs_folder = \"docs\" , replacements = \"\" , replacements_separator = \"|\" , internal_separator = \",\" , ): \"\"\"Create the documentation index page from README.md.\"\"\" readme : Path = REPO_PARENT_DIR / repo_folder / \"README.md\" docs_index : Path = REPO_PARENT_DIR / repo_folder / docs_folder / \"index.md\" content = readme . read_text ( encoding = \"utf8\" ) replacement_mapping = [( f \" { docs_folder } /\" , \"\" )] for replacement in replacements . split ( replacements_separator ): new_replacement_map = replacement . split ( internal_separator ) if len ( new_replacement_map ) != 2 : sys . exit ( \"A single replacement must only include an 'old' and 'new' part, \" \"i.e., be of exactly length 2 when split by the \" \"'--internal-separator'. The following replacement did not fulfill \" f \"this requirement: { replacement !r} \\n \" f \"--internal-separator= { internal_separator !r} \\n \" f \"--replacements-separator= { replacements_separator !r} \" ) replacement_mapping . append ( tuple ( new_replacement_map )) for old , new in replacement_mapping : content = content . replace ( old , new ) docs_index . write_text ( content , encoding = \"utf8\" )","title":"create_docs_index()"},{"location":"python/tasks/#tasks.setver","text":"Sets the specified version of specified Python package. Source code in ci-cd/tasks.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @task ( help = { \"version\" : \"Version to set.\" , \"package-dir\" : ( \"Relative path to package dir from the repository root, \" \"e.g. 'src/my_package'.\" ), \"repo-folder\" : ( \"The folder name of the repository, wherein the package dir is located. \" \"This defaults to 'main', as this will be used in the callable workflows.\" ), } ) def setver ( _ , package_dir , version , repo_folder = \"main\" ): \"\"\"Sets the specified version of specified Python package.\"\"\" match = re . fullmatch ( ( r \"v?(?P<version>[0-9]+(\\.[0-9]+) {2} \" # Major.Minor.Patch r \"(-[0-9A-Za-z-]+(\\.[0-9A-Za-z-]+)*)?\" # pre-release r \"(\\+[0-9A-Za-z-]+(\\.[0-9A-Za-z-]+)*)?)\" # build metadata ), version , ) if not match : sys . exit ( \"Error: Please specify version as \" \"'Major.Minor.Patch(-Pre-Release+Build Metadata)' or \" \"'vMajor.Minor.Patch(-Pre-Release+Build Metadata)'\" ) version = match . group ( \"version\" ) init_file : Path = REPO_PARENT_DIR / repo_folder / package_dir / \"__init__.py\" if not init_file . exists (): sys . exit ( \"Error: Could not find the Python package's root '__init__.py' file at: \" f \" { init_file } \" ) update_file ( init_file , ( r '__version__ *= *( \\' |\").*( \\' |\")' , f '__version__ = \" { version } \"' ), ) print ( f \"Bumped version for { package_dir } to { version } .\" )","title":"setver()"},{"location":"python/tasks/#tasks.update_deps","text":"Update dependencies in specified Python package's pyproject.toml . Source code in ci-cd/tasks.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 @task ( help = { \"fail-fast\" : ( \"Fail immediately if an error occurs. Otherwise, print and ignore all \" \"non-critical errors.\" ), \"repo-folder\" : ( \"The folder name of the repository, wherein the package dir is located. \" \"This defaults to 'main', as this will be used in the callable workflows.\" ), } ) def update_deps ( # pylint: disable=too-many-branches,too-many-locals,too-many-statements context , repo_folder = \"main\" , fail_fast = False ): \"\"\"Update dependencies in specified Python package's `pyproject.toml`.\"\"\" import tomlkit if TYPE_CHECKING : # pragma: no cover context : \"Context\" = context pyproject_path = REPO_PARENT_DIR / repo_folder / \"pyproject.toml\" if not pyproject_path . exists (): sys . exit ( \"Error: Could not find the Python package repository's 'pyproject.toml' \" f \"file at: { pyproject_path } \" ) pyproject = tomlkit . loads ( pyproject_path . read_bytes ()) py_version = re . match ( r \"^.*(?P<version>3\\.[0-9]+)$\" , pyproject . get ( \"project\" , {}) . get ( \"requires-python\" , \"\" ), ) . group ( \"version\" ) already_handled_packages = set () updated_packages = {} dependencies = pyproject . get ( \"project\" , {}) . get ( \"dependencies\" , []) for optional_deps in ( pyproject . get ( \"project\" , {}) . get ( \"optional-dependencies\" , {}) . values () ): dependencies . extend ( optional_deps ) for line in dependencies : match = re . match ( r \"^(?P<full_dependency>(?P<package>[a-zA-Z0-9-_]+)\\S*) \" r \"(?P<operator>>|<|<=|>=|==|!=|~=)\" r \"(?P<version>[0-9]+(?:\\.[0-9]+){0,2})\" r \"(?P<extra_op_ver>(?:,(?:>|<|<=|>=|==|!=|~=)\" r \"[0-9]+(?:\\.[0-9]+){0,2})*)$\" , line , ) if match is None : msg = f \"Could not parse package, operator, and version for line: \\n { line } \" if fail_fast : sys . exit ( msg ) print ( msg ) full_dependency_name = match . group ( \"full_dependency\" ) package = match . group ( \"package\" ) operator = match . group ( \"operator\" ) version = match . group ( \"version\" ) extra_op_ver = match . group ( \"extra_op_ver\" ) # Skip package if already handled if package in already_handled_packages : continue # Check version from PyPI's online package index out : \"Result\" = context . run ( f \"pip index versions --python-version { py_version } { package } \" , hide = True , ) package_latest_version_line = out . stdout . split ( sep = \" \\n \" , maxsplit = 1 )[ 0 ] match = re . match ( r \"(?P<package>[a-zA-Z0-9-_]+) \\((?P<version>[0-9]+(?:\\.[0-9]+){0,2})\\)\" , package_latest_version_line , ) if match is None : msg = ( \"Could not parse package and version from 'pip index versions' output \" f \"for line: \\n { package_latest_version_line } \" ) if fail_fast : sys . exit ( msg ) print ( msg ) # Sanity check if package != match . group ( \"package\" ): msg = ( f \"Package name parsed from pyproject.toml ( { package !r} ) does not match\" \" the name returned from 'pip index versions': \" f \" { match . group ( 'package' ) !r} \" ) if fail_fast : sys . exit ( msg ) print ( msg ) latest_version = match . group ( \"version\" ) . split ( \".\" ) for index , version_part in enumerate ( version . split ( \".\" )): if version_part != latest_version [ index ]: break else : already_handled_packages . add ( package ) continue # Update pyproject.toml updated_version = \".\" . join ( latest_version [: len ( version . split ( \".\" ))]) escaped_full_dependency_name = full_dependency_name . replace ( \"[\" , \"\\[\" # pylint: disable=anomalous-backslash-in-string ) . replace ( \"]\" , \"\\]\" # pylint: disable=anomalous-backslash-in-string ) update_file ( pyproject_path , ( rf '\" { escaped_full_dependency_name } { operator } .*\"' , f '\" { full_dependency_name } { operator }{ updated_version } ' f ' { extra_op_ver if extra_op_ver else \"\" } \"' , ), ) already_handled_packages . add ( package ) updated_packages [ full_dependency_name ] = f \" { operator }{ updated_version } \" if updated_packages : print ( \"Successfully updated the following dependencies: \\n \" + \" \\n \" . join ( f \" { package } ( { version }{ extra_op_ver if extra_op_ver else '' } )\" for package , version in updated_packages . items () ) + \" \\n \" ) else : print ( \"No dependency updates available.\" )","title":"update_deps()"},{"location":"python/tasks/#tasks.update_file","text":"Utility function for tasks to read, update, and write files Source code in ci-cd/tasks.py 21 22 23 24 25 26 27 def update_file ( filename : Path , sub_line : \"Tuple[str, str]\" , strip : str = None ) -> None : \"\"\"Utility function for tasks to read, update, and write files\"\"\" lines = [ re . sub ( sub_line [ 0 ], sub_line [ 1 ], line . rstrip ( strip )) for line in filename . read_text ( encoding = \"utf8\" ) . splitlines () ] filename . write_text ( \" \\n \" . join ( lines ) + \" \\n \" , encoding = \"utf8\" )","title":"update_file()"},{"location":"workflows/","text":"Workflows \u00b6 This section contains all the available callable/reusable workflows: CD - Release ( cd_release.yml ) CI - Activate auto-merging for PRs ( ci_automerge_prs.yml ) CI/CD - New updates to default branch ( ci_cd_updated_default_branch.yml )) CI - Check pyproject.toml dependencies ( ci_check_pyproject_dependencies.yml ) CI - Update dependencies PR ( ci_update_dependencies.yml )","title":"Overview"},{"location":"workflows/#workflows","text":"This section contains all the available callable/reusable workflows: CD - Release ( cd_release.yml ) CI - Activate auto-merging for PRs ( ci_automerge_prs.yml ) CI/CD - New updates to default branch ( ci_cd_updated_default_branch.yml )) CI - Check pyproject.toml dependencies ( ci_check_pyproject_dependencies.yml ) CI - Update dependencies PR ( ci_update_dependencies.yml )","title":"Workflows"},{"location":"workflows/cd_release/","text":"CD - Release ( cd_release.yml ) \u00b6 There are 2 jobs in this workflow, which run in sequence. First, an update & publish job, which updates the version in the package's root __init__.py file through an Invoke task. The newly created tag (created due to the caller workflow running on.release.types.published ) will be updated accordingly, as will the publish branch (defaults to main ). Secondly, a job to update the documentation is run, however, this can be deactivated. The job expects the documentation to be setup with the mike + MkDocs + GitHub Pages framework. For more information about the specific changelog inputs, see the related changelog generator actually used, specifically the list of configuration options . Note Concerning the changelog generator, the specific input changelog_exclude_labels defaults to a list of different labels if not supplied, hence, if supplied, one might want to include these labels alongside any extra labels. The default value is given here as a help: 'duplicate,question,invalid,wontfix' The changelog_exclude_tags_regex is also used to remove tags in a list of tags to consider when evaluating the \"previous version\". This is specifically for adding a changelog to the GitHub release body. Expectations \u00b6 This workflow should only be used for releasing a single modern Python package. The repository contains the following: ( required ) A Python package root __init__.py file with __version__ defined. ( required ) The workflow is run for a tag that starts with v followed by a full semantic version. This will automatically be the case for a GitHub release, which creates a new tag that starts with v . See SemVer.org for more information about semantic versioning. Inputs \u00b6 Name Descriptions Required Default Type git_username A git username (used to set the 'user.name' config option). Yes string git_email A git user's email address (used to set the 'user.email' config option). Yes string python_package Whether or not this is a Python package, where the version should be updated in the 'package_dir'/__init__.py and a build and release to PyPI should be performed. No true boolean package_dir Path to the Python package directory relative to the repository directory. Example: 'src/my_package' . Important : This is required if 'python_package' is 'true', which is the default. Yes (if 'python_package' is 'true' string release_branch The branch name to release/publish from. No main string install_extras Any extras to install from the local repository through 'pip'. Must be encapsulated in square parentheses ( [] ) and be separated by commas ( , ) without any spaces. Example: '[dev,release]' . No Empty string string python_version The Python version to use for the workflow. No 3.9 string build_cmd The package build command, e.g., 'pip install flit && flit build' or 'python -m build' (default). No python -m build string tag_message_file Relative path to a release tag message file from the root of the repository. Example: '.github/utils/release_tag_msg.txt' . No Empty string string publish_on_pypi Whether or not to publish on PyPI. Note : This is only relevant if 'python_package' is 'true', which is the default. No true boolean test Whether to use the TestPyPI repository index instead of PyPI. No false boolean update_docs Whether or not to also run the 'docs' workflow job. No false boolean doc_extras Any extras to install from the local repository through 'pip'. Must be encapsulated in square parentheses ( [] ) and be separated by commas ( , ) without any spaces. Note, if this is empty, 'install_extras' will be used as a fallback. Example: '[docs]' . No Empty string string changelog_exclude_tags_regex A regular expression matching any tags that should be excluded from the CHANGELOG.md. No Empty string string changelog_exclude_labels Comma-separated list of labels to exclude from the CHANGELOG.md. No Empty string string Secrets \u00b6 Name Descriptions Required PyPI_token A PyPI token for publishing the built package to PyPI. Important : This is required if both 'python_package' and 'publish_on_pypi' are 'true'. Both are 'true' by default. Yes (if 'python_package' and 'publish_on_pypi' are 'true') PAT A personal access token (PAT) with rights to update the release_branch . This will fallback on GITHUB_TOKEN . No Usage example \u00b6 The following is an example of how a workflow may look that calls CD - Release . It is meant to be complete as is. name : CD - Publish on : release : types : - published jobs : publish : name : Publish package and documentation uses : CasperWA/ci-cd/.github/workflows/cd_release.yml@main if : github.repository == 'CasperWA/my-python-package' && startsWith(github.ref, 'refs/tags/v') with : git_username : \"Casper Welzel Andersen\" git_email : \"CasperWA@github.com\" release_branch : stable install_extras : \"[dev,build]\" build_cmd : \"pip install flit && flit build\" tag_message_file : \".github/utils/release_tag_msg.txt\" update_docs : true doc_extras : \"[docs]\" exclude_labels : \"skip_changelog,duplicate\" secrets : PyPI_token : ${{ secrets.PYPI_TOKEN }} PAT : ${{ secrets.PAT }}","title":"CD - Release"},{"location":"workflows/cd_release/#cd-release-cd_releaseyml","text":"There are 2 jobs in this workflow, which run in sequence. First, an update & publish job, which updates the version in the package's root __init__.py file through an Invoke task. The newly created tag (created due to the caller workflow running on.release.types.published ) will be updated accordingly, as will the publish branch (defaults to main ). Secondly, a job to update the documentation is run, however, this can be deactivated. The job expects the documentation to be setup with the mike + MkDocs + GitHub Pages framework. For more information about the specific changelog inputs, see the related changelog generator actually used, specifically the list of configuration options . Note Concerning the changelog generator, the specific input changelog_exclude_labels defaults to a list of different labels if not supplied, hence, if supplied, one might want to include these labels alongside any extra labels. The default value is given here as a help: 'duplicate,question,invalid,wontfix' The changelog_exclude_tags_regex is also used to remove tags in a list of tags to consider when evaluating the \"previous version\". This is specifically for adding a changelog to the GitHub release body.","title":"CD - Release (cd_release.yml)"},{"location":"workflows/cd_release/#expectations","text":"This workflow should only be used for releasing a single modern Python package. The repository contains the following: ( required ) A Python package root __init__.py file with __version__ defined. ( required ) The workflow is run for a tag that starts with v followed by a full semantic version. This will automatically be the case for a GitHub release, which creates a new tag that starts with v . See SemVer.org for more information about semantic versioning.","title":"Expectations"},{"location":"workflows/cd_release/#inputs","text":"Name Descriptions Required Default Type git_username A git username (used to set the 'user.name' config option). Yes string git_email A git user's email address (used to set the 'user.email' config option). Yes string python_package Whether or not this is a Python package, where the version should be updated in the 'package_dir'/__init__.py and a build and release to PyPI should be performed. No true boolean package_dir Path to the Python package directory relative to the repository directory. Example: 'src/my_package' . Important : This is required if 'python_package' is 'true', which is the default. Yes (if 'python_package' is 'true' string release_branch The branch name to release/publish from. No main string install_extras Any extras to install from the local repository through 'pip'. Must be encapsulated in square parentheses ( [] ) and be separated by commas ( , ) without any spaces. Example: '[dev,release]' . No Empty string string python_version The Python version to use for the workflow. No 3.9 string build_cmd The package build command, e.g., 'pip install flit && flit build' or 'python -m build' (default). No python -m build string tag_message_file Relative path to a release tag message file from the root of the repository. Example: '.github/utils/release_tag_msg.txt' . No Empty string string publish_on_pypi Whether or not to publish on PyPI. Note : This is only relevant if 'python_package' is 'true', which is the default. No true boolean test Whether to use the TestPyPI repository index instead of PyPI. No false boolean update_docs Whether or not to also run the 'docs' workflow job. No false boolean doc_extras Any extras to install from the local repository through 'pip'. Must be encapsulated in square parentheses ( [] ) and be separated by commas ( , ) without any spaces. Note, if this is empty, 'install_extras' will be used as a fallback. Example: '[docs]' . No Empty string string changelog_exclude_tags_regex A regular expression matching any tags that should be excluded from the CHANGELOG.md. No Empty string string changelog_exclude_labels Comma-separated list of labels to exclude from the CHANGELOG.md. No Empty string string","title":"Inputs"},{"location":"workflows/cd_release/#secrets","text":"Name Descriptions Required PyPI_token A PyPI token for publishing the built package to PyPI. Important : This is required if both 'python_package' and 'publish_on_pypi' are 'true'. Both are 'true' by default. Yes (if 'python_package' and 'publish_on_pypi' are 'true') PAT A personal access token (PAT) with rights to update the release_branch . This will fallback on GITHUB_TOKEN . No","title":"Secrets"},{"location":"workflows/cd_release/#usage-example","text":"The following is an example of how a workflow may look that calls CD - Release . It is meant to be complete as is. name : CD - Publish on : release : types : - published jobs : publish : name : Publish package and documentation uses : CasperWA/ci-cd/.github/workflows/cd_release.yml@main if : github.repository == 'CasperWA/my-python-package' && startsWith(github.ref, 'refs/tags/v') with : git_username : \"Casper Welzel Andersen\" git_email : \"CasperWA@github.com\" release_branch : stable install_extras : \"[dev,build]\" build_cmd : \"pip install flit && flit build\" tag_message_file : \".github/utils/release_tag_msg.txt\" update_docs : true doc_extras : \"[docs]\" exclude_labels : \"skip_changelog,duplicate\" secrets : PyPI_token : ${{ secrets.PYPI_TOKEN }} PAT : ${{ secrets.PAT }}","title":"Usage example"},{"location":"workflows/ci_automerge_prs/","text":"CI - Activate auto-merging for PRs ( ci_automerge_prs.yml ) \u00b6 Activate auto-merging for a PR. Expectations \u00b6 The PAT secret must represent a user with the rights to activate auto-merging. This workflow can only be called if the triggering event from the caller workflow is pull_request_target . Inputs \u00b6 There are no inputs for this workflow. Secrets \u00b6 Name Descriptions Required PAT A personal access token (PAT) with rights to update the permanent_dependencies_branch . This will fallback on GITHUB_TOKEN . No Usage example \u00b6 The following is an example of how a workflow may look that calls CI - Activate auto-merging for PRs . It is meant to be complete as is. name : CI - Activate auto-merging for Dependabot PRs on : pull_request_target : branches : - ci/dependency-updates jobs : update-dependency-branch : name : Call external workflow uses : CasperWA/ci-cd/.github/workflows/ci_automerge_prs.yml@main if : github.repository_owner == 'CasperWA' && ( ( startsWith(github.event.pull_request.head.ref, 'dependabot/') && github.actor == 'dependabot[bot]' ) || ( github.event.pull_request.head.ref == 'ci/update-pyproject' && github.actor == 'CasperWA' ) ) secrets : PAT : ${{ secrets.RELEASE_PAT }}","title":"CI - Activate auto-merging for PRs"},{"location":"workflows/ci_automerge_prs/#ci-activate-auto-merging-for-prs-ci_automerge_prsyml","text":"Activate auto-merging for a PR.","title":"CI - Activate auto-merging for PRs (ci_automerge_prs.yml)"},{"location":"workflows/ci_automerge_prs/#expectations","text":"The PAT secret must represent a user with the rights to activate auto-merging. This workflow can only be called if the triggering event from the caller workflow is pull_request_target .","title":"Expectations"},{"location":"workflows/ci_automerge_prs/#inputs","text":"There are no inputs for this workflow.","title":"Inputs"},{"location":"workflows/ci_automerge_prs/#secrets","text":"Name Descriptions Required PAT A personal access token (PAT) with rights to update the permanent_dependencies_branch . This will fallback on GITHUB_TOKEN . No","title":"Secrets"},{"location":"workflows/ci_automerge_prs/#usage-example","text":"The following is an example of how a workflow may look that calls CI - Activate auto-merging for PRs . It is meant to be complete as is. name : CI - Activate auto-merging for Dependabot PRs on : pull_request_target : branches : - ci/dependency-updates jobs : update-dependency-branch : name : Call external workflow uses : CasperWA/ci-cd/.github/workflows/ci_automerge_prs.yml@main if : github.repository_owner == 'CasperWA' && ( ( startsWith(github.event.pull_request.head.ref, 'dependabot/') && github.actor == 'dependabot[bot]' ) || ( github.event.pull_request.head.ref == 'ci/update-pyproject' && github.actor == 'CasperWA' ) ) secrets : PAT : ${{ secrets.RELEASE_PAT }}","title":"Usage example"},{"location":"workflows/ci_cd_updated_default_branch/","text":"CI/CD - New updates to default branch ( ci_cd_updated_default_branch.yml ) \u00b6 Keep your permanent_dependencies_branch branch up-to-date with changes in your main development branch, i.e., the default_repo_branch . Furthermore, this workflow can optionally update the latest mike + MkDocs + GitHub Pages -framework documentation release alias, which represents the default_repo_branch . Warning If a PAT is not passed through for the PAT secret and GITHUB_TOKEN is used, beware that any other CI/CD jobs that run for, e.g., pull request events, may not run since GITHUB_TOKEN -generated PRs are designed to not start more workflows to avoid escalation. Hence, if it is important to run CI/CD workflows for pull requests, consider passing a PAT as a secret to this workflow represented by the PAT secret. Important If this is to be used together with the CI - Update dependencies PR workflow, the pr_body_file supplied to that workflow (if any) should match the update_depednencies_pr_body_file input in this workflow and be immutable within the first 8 lines, i.e., no check boxes or similar in the first 8 lines. Indeed, it is recommended to not supply pr_body_file to the CI - Update dependencies PR workflow as well as to not supply the update_dependencies_pr_body_file in this workflow in this case. Note Concerning the changelog generator, the specific input changelog_exclude_labels defaults to a list of different labels if not supplied, hence, if supplied, one might want to include these labels alongside any extra labels. The default value is given here as a help: 'duplicate,question,invalid,wontfix' Expectations \u00b6 The repository contains the following: ( required ) A single Python package is contained in the package_dir directory. ( required ) Only if also updating the documentation , then the documentation should be contained in a root docs directory. ( required ) Only if also updating the documentation , then a root README.md file must exist and desired to be used as the documentation's landing page if the update_docs_landing_page is set to true , which is the default. Inputs \u00b6 Name Descriptions Required Default Type git_username A git username (used to set the 'user.name' config option). Yes string git_email A git user's email address (used to set the 'user.email' config option). Yes string permanent_dependencies_branch The branch name for the permanent dependency updates branch. No ci/dependency-updates string default_repo_branch The branch name of the repository's default branch. More specifically, the branch the PR should target. No main string update_dependencies_pr_body_file Relative path to a PR body file from the root of the repository, which is used in the 'CI - Update dependencies PR' workflow, if used. Example: '.github/utils/pr_body_update_deps.txt' . No Empty string string update_docs Whether or not to also run the 'docs' workflow job. No false boolean update_python_api_ref Whether or not to update the Python API documentation reference. Note : If this is 'true', 'package_dir' is required . No true boolean package_dir Path to the Python package directory relative to the repository directory. Example: 'src/my_package' . Important : This is required if 'update_docs' and 'update_python_api_ref' are 'true'. Yes (if 'update_docs' and 'update_python_api_ref' are 'true') string update_docs_landing_page Whether or not to update the documentation landing page. The landing page will be based on the root README.md file. No true boolean python_version The Python version to use for the workflow. Note : This is only relevant if update_pre-commit is true . No 3.9 string doc_extras Any extras to install from the local repository through 'pip'. Must be encapsulated in square parentheses ( [] ) and be separated by commas ( , ) without any spaces. Example: '[docs]' . No Empty string string exclude_dirs Comma-separated list of directories to exclude in the Python API reference documentation. Note, only directory names, not paths, may be included. Note, all folders and their contents with these names will be excluded. Defaults to '__pycache__' . Important : When a user value is set, the preset value is overwritten - hence '__pycache__' should be included in the user value if one wants to exclude these directories. No __pycache__ string exclude_files Comma-separated list of files to exclude in the Python API reference documentation. Note, only full file names, not paths, may be included, i.e., filename + file extension. Note, all files with these names will be excluded. Defaults to '__init__.py' . Important : When a user value is set, the preset value is overwritten - hence '__init__.py' should be included in the user value if one wants to exclude these files. No __init__.py string full_docs_dirs Comma-separated list of directories in which to include everything - even those without documentation strings. This may be useful for a module full of data models or to ensure all class attributes are listed. No Empty string string landing_page_replacements List of replacements (mappings) to be performed on README.md when creating the documentation's landing page (index.md). This list always includes replacing 'docs/' with an empty string to correct relative links, i.e., this cannot be overwritten. By default '(LICENSE)' is replaced by '(LICENSE.md)' . No (LICENSE),(LICENSE.md) string landing_page_replacements_separator String to separate replacement mappings from the 'replacements' input. Defaults to a pipe ( \\| ). No | string landing_page_replacements_mapping_separator String to separate a single mapping's 'old' to 'new' statement. Defaults to a comma ( , ). No , string test Whether to do a \"dry run\", i.e., run the workflow, but avoid pushing to 'permanent_dependencies_branch' branch and deploying documentation (if 'update_docs' is 'true'). No false boolean changelog_exclude_tags_regex A regular expression matching any tags that should be excluded from the CHANGELOG.md. No Empty string string changelog_exclude_labels Comma-separated list of labels to exclude from the CHANGELOG.md. No Empty string string Secrets \u00b6 Name Descriptions Required PAT A personal access token (PAT) with rights to update the permanent_dependencies_branch . This will fallback on GITHUB_TOKEN . No Usage example \u00b6 The following is an example of how a workflow may look that calls CI/CD - New updates to default branch . It is meant to be complete as is. name : CI - Activate auto-merging for Dependabot PRs on : push : branches : - stable jobs : updates-to-stable : name : Call external workflow uses : CasperWA/ci-cd/.github/workflows/ci_cd_updated_default_branch.yml@main if : github.repository_owner == 'CasperWA' inputs : git_username : \"Casper Welzel Andersen\" git_email : \"CasperWA@github.com\" default_repo_branch : stable permanent_dependencies_branch : \"ci/dependency-updates\" update_docs : true package_dir : my-python-package doc_extras : \"[docs]\" exclude_files : __init__.py,config.py full_docs_dirs : models landing_page_replacements : \"(LICENSE);(LICENSE.md)|(tools);(../tools)\" landing_page_replacements_mapping_separator : \";\" secrets : PAT : ${{ secrets.PAT }}","title":"CI/CD - New updates to default branch"},{"location":"workflows/ci_cd_updated_default_branch/#cicd-new-updates-to-default-branch-ci_cd_updated_default_branchyml","text":"Keep your permanent_dependencies_branch branch up-to-date with changes in your main development branch, i.e., the default_repo_branch . Furthermore, this workflow can optionally update the latest mike + MkDocs + GitHub Pages -framework documentation release alias, which represents the default_repo_branch . Warning If a PAT is not passed through for the PAT secret and GITHUB_TOKEN is used, beware that any other CI/CD jobs that run for, e.g., pull request events, may not run since GITHUB_TOKEN -generated PRs are designed to not start more workflows to avoid escalation. Hence, if it is important to run CI/CD workflows for pull requests, consider passing a PAT as a secret to this workflow represented by the PAT secret. Important If this is to be used together with the CI - Update dependencies PR workflow, the pr_body_file supplied to that workflow (if any) should match the update_depednencies_pr_body_file input in this workflow and be immutable within the first 8 lines, i.e., no check boxes or similar in the first 8 lines. Indeed, it is recommended to not supply pr_body_file to the CI - Update dependencies PR workflow as well as to not supply the update_dependencies_pr_body_file in this workflow in this case. Note Concerning the changelog generator, the specific input changelog_exclude_labels defaults to a list of different labels if not supplied, hence, if supplied, one might want to include these labels alongside any extra labels. The default value is given here as a help: 'duplicate,question,invalid,wontfix'","title":"CI/CD - New updates to default branch (ci_cd_updated_default_branch.yml)"},{"location":"workflows/ci_cd_updated_default_branch/#expectations","text":"The repository contains the following: ( required ) A single Python package is contained in the package_dir directory. ( required ) Only if also updating the documentation , then the documentation should be contained in a root docs directory. ( required ) Only if also updating the documentation , then a root README.md file must exist and desired to be used as the documentation's landing page if the update_docs_landing_page is set to true , which is the default.","title":"Expectations"},{"location":"workflows/ci_cd_updated_default_branch/#inputs","text":"Name Descriptions Required Default Type git_username A git username (used to set the 'user.name' config option). Yes string git_email A git user's email address (used to set the 'user.email' config option). Yes string permanent_dependencies_branch The branch name for the permanent dependency updates branch. No ci/dependency-updates string default_repo_branch The branch name of the repository's default branch. More specifically, the branch the PR should target. No main string update_dependencies_pr_body_file Relative path to a PR body file from the root of the repository, which is used in the 'CI - Update dependencies PR' workflow, if used. Example: '.github/utils/pr_body_update_deps.txt' . No Empty string string update_docs Whether or not to also run the 'docs' workflow job. No false boolean update_python_api_ref Whether or not to update the Python API documentation reference. Note : If this is 'true', 'package_dir' is required . No true boolean package_dir Path to the Python package directory relative to the repository directory. Example: 'src/my_package' . Important : This is required if 'update_docs' and 'update_python_api_ref' are 'true'. Yes (if 'update_docs' and 'update_python_api_ref' are 'true') string update_docs_landing_page Whether or not to update the documentation landing page. The landing page will be based on the root README.md file. No true boolean python_version The Python version to use for the workflow. Note : This is only relevant if update_pre-commit is true . No 3.9 string doc_extras Any extras to install from the local repository through 'pip'. Must be encapsulated in square parentheses ( [] ) and be separated by commas ( , ) without any spaces. Example: '[docs]' . No Empty string string exclude_dirs Comma-separated list of directories to exclude in the Python API reference documentation. Note, only directory names, not paths, may be included. Note, all folders and their contents with these names will be excluded. Defaults to '__pycache__' . Important : When a user value is set, the preset value is overwritten - hence '__pycache__' should be included in the user value if one wants to exclude these directories. No __pycache__ string exclude_files Comma-separated list of files to exclude in the Python API reference documentation. Note, only full file names, not paths, may be included, i.e., filename + file extension. Note, all files with these names will be excluded. Defaults to '__init__.py' . Important : When a user value is set, the preset value is overwritten - hence '__init__.py' should be included in the user value if one wants to exclude these files. No __init__.py string full_docs_dirs Comma-separated list of directories in which to include everything - even those without documentation strings. This may be useful for a module full of data models or to ensure all class attributes are listed. No Empty string string landing_page_replacements List of replacements (mappings) to be performed on README.md when creating the documentation's landing page (index.md). This list always includes replacing 'docs/' with an empty string to correct relative links, i.e., this cannot be overwritten. By default '(LICENSE)' is replaced by '(LICENSE.md)' . No (LICENSE),(LICENSE.md) string landing_page_replacements_separator String to separate replacement mappings from the 'replacements' input. Defaults to a pipe ( \\| ). No | string landing_page_replacements_mapping_separator String to separate a single mapping's 'old' to 'new' statement. Defaults to a comma ( , ). No , string test Whether to do a \"dry run\", i.e., run the workflow, but avoid pushing to 'permanent_dependencies_branch' branch and deploying documentation (if 'update_docs' is 'true'). No false boolean changelog_exclude_tags_regex A regular expression matching any tags that should be excluded from the CHANGELOG.md. No Empty string string changelog_exclude_labels Comma-separated list of labels to exclude from the CHANGELOG.md. No Empty string string","title":"Inputs"},{"location":"workflows/ci_cd_updated_default_branch/#secrets","text":"Name Descriptions Required PAT A personal access token (PAT) with rights to update the permanent_dependencies_branch . This will fallback on GITHUB_TOKEN . No","title":"Secrets"},{"location":"workflows/ci_cd_updated_default_branch/#usage-example","text":"The following is an example of how a workflow may look that calls CI/CD - New updates to default branch . It is meant to be complete as is. name : CI - Activate auto-merging for Dependabot PRs on : push : branches : - stable jobs : updates-to-stable : name : Call external workflow uses : CasperWA/ci-cd/.github/workflows/ci_cd_updated_default_branch.yml@main if : github.repository_owner == 'CasperWA' inputs : git_username : \"Casper Welzel Andersen\" git_email : \"CasperWA@github.com\" default_repo_branch : stable permanent_dependencies_branch : \"ci/dependency-updates\" update_docs : true package_dir : my-python-package doc_extras : \"[docs]\" exclude_files : __init__.py,config.py full_docs_dirs : models landing_page_replacements : \"(LICENSE);(LICENSE.md)|(tools);(../tools)\" landing_page_replacements_mapping_separator : \";\" secrets : PAT : ${{ secrets.PAT }}","title":"Usage example"},{"location":"workflows/ci_check_pyproject_dependencies/","text":"CI - Check pyproject.toml dependencies ( ci_check_pyproject_dependencies.yml ) \u00b6 This workflow runs an Invoke task to check dependencies in a pyproject.toml file. The reason for having this workflow and not using Dependabot is because it seems to not function properly with this use case. Warning If a PAT is not passed through for the PAT secret and GITHUB_TOKEN is used, beware that any other CI/CD jobs that run for, e.g., pull request events, may not run since GITHUB_TOKEN -generated PRs are designed to not start more workflows to avoid escalation. Hence, if it is important to run CI/CD workflows for pull requests, consider passing a PAT as a secret to this workflow represented by the PAT secret. Expectations \u00b6 The repository contains the following: ( required ) A repository root pyproject.toml file with the Python package's dependencies. Inputs \u00b6 Name Descriptions Required Default Type git_username A git username (used to set the 'user.name' config option). Yes string git_email A git user's email address (used to set the 'user.email' config option). Yes string permanent_dependencies_branch The branch name for the permanent dependency updates branch. No ci/dependency-updates string python_version The Python version to use for the workflow. No 3.9 string install_extras Any extras to install from the local repository through 'pip'. Must be encapsulated in square parentheses ( [] ) and be separated by commas ( , ) without any spaces. Example: '[dev,release]' . No Empty string string pr_body_file Relative path to PR body file from the root of the repository. Example: '.github/utils/pr_body_deps_check.txt' . No Empty string string fail_fast Whether the task to update dependencies should fail if any error occurs. No false boolean pr_labels A comma separated list of strings of GitHub labels to use for the created PR. No Empty string string Secrets \u00b6 Name Descriptions Required PAT A personal access token (PAT) with rights to update the permanent_dependencies_branch . This will fallback on GITHUB_TOKEN . No Usage example \u00b6 The following is an example of how a workflow may look that calls CI - Check pyproject.toml dependencies . It is meant to be complete as is. name : CI - Check dependencies on : schedule : - cron : \"30 5 * * 1\" workflow_dispatch : jobs : check-dependencies : name : Call external workflow uses : CasperWA/ci-cd/.github/workflows/ci_check_pyproject_dependencies.yml@main if : github.repository_owner == 'CasperWA' inputs : git_username : \"Casper Welzel Andersen\" git_email : \"CasperWA@github.com\" permanent_dependencies_branch : \"ci/dependency-updates\" python_version : \"3.9\" install_extras : \"[dev]\" pr_labels : \"CI/CD\" secrets : PAT : ${{ secrets.PAT }}","title":"CI - Check pyproject.toml dependencies"},{"location":"workflows/ci_check_pyproject_dependencies/#ci-check-pyprojecttoml-dependencies-ci_check_pyproject_dependenciesyml","text":"This workflow runs an Invoke task to check dependencies in a pyproject.toml file. The reason for having this workflow and not using Dependabot is because it seems to not function properly with this use case. Warning If a PAT is not passed through for the PAT secret and GITHUB_TOKEN is used, beware that any other CI/CD jobs that run for, e.g., pull request events, may not run since GITHUB_TOKEN -generated PRs are designed to not start more workflows to avoid escalation. Hence, if it is important to run CI/CD workflows for pull requests, consider passing a PAT as a secret to this workflow represented by the PAT secret.","title":"CI - Check pyproject.toml dependencies (ci_check_pyproject_dependencies.yml)"},{"location":"workflows/ci_check_pyproject_dependencies/#expectations","text":"The repository contains the following: ( required ) A repository root pyproject.toml file with the Python package's dependencies.","title":"Expectations"},{"location":"workflows/ci_check_pyproject_dependencies/#inputs","text":"Name Descriptions Required Default Type git_username A git username (used to set the 'user.name' config option). Yes string git_email A git user's email address (used to set the 'user.email' config option). Yes string permanent_dependencies_branch The branch name for the permanent dependency updates branch. No ci/dependency-updates string python_version The Python version to use for the workflow. No 3.9 string install_extras Any extras to install from the local repository through 'pip'. Must be encapsulated in square parentheses ( [] ) and be separated by commas ( , ) without any spaces. Example: '[dev,release]' . No Empty string string pr_body_file Relative path to PR body file from the root of the repository. Example: '.github/utils/pr_body_deps_check.txt' . No Empty string string fail_fast Whether the task to update dependencies should fail if any error occurs. No false boolean pr_labels A comma separated list of strings of GitHub labels to use for the created PR. No Empty string string","title":"Inputs"},{"location":"workflows/ci_check_pyproject_dependencies/#secrets","text":"Name Descriptions Required PAT A personal access token (PAT) with rights to update the permanent_dependencies_branch . This will fallback on GITHUB_TOKEN . No","title":"Secrets"},{"location":"workflows/ci_check_pyproject_dependencies/#usage-example","text":"The following is an example of how a workflow may look that calls CI - Check pyproject.toml dependencies . It is meant to be complete as is. name : CI - Check dependencies on : schedule : - cron : \"30 5 * * 1\" workflow_dispatch : jobs : check-dependencies : name : Call external workflow uses : CasperWA/ci-cd/.github/workflows/ci_check_pyproject_dependencies.yml@main if : github.repository_owner == 'CasperWA' inputs : git_username : \"Casper Welzel Andersen\" git_email : \"CasperWA@github.com\" permanent_dependencies_branch : \"ci/dependency-updates\" python_version : \"3.9\" install_extras : \"[dev]\" pr_labels : \"CI/CD\" secrets : PAT : ${{ secrets.PAT }}","title":"Usage example"},{"location":"workflows/ci_update_dependencies/","text":"CI - Update dependencies PR ( ci_update_dependencies.yml ) \u00b6 This workflow creates a PR if there are any updates in the permanent_dependencies_branch branch that have not been included in the default_repo_branch branch. This workflow works nicely together with the CI - Check pyproject.toml dependencies workflow, and the same value for permanent_dependencies_branch should be used. In this way, this workflow can be called on a schedule to update the dependencies that have been merged into the permanent_dependencies_branch branch into the default_repo_branch branch. The main point of having this workflow is to have a single PR, which can be squash merged, to merge several dependency updates performed by Dependabot or similar. As a \"bonus\" this workflow supports updating pre-commit hooks. Warning If a PAT is not passed through for the PAT secret and GITHUB_TOKEN is used, beware that any other CI/CD jobs that run for, e.g., pull request events, may not run since GITHUB_TOKEN -generated PRs are designed to not start more workflows to avoid escalation. Hence, if it is important to run CI/CD workflows for pull requests, consider passing a PAT as a secret to this workflow represented by the PAT secret. Important If this is to be used together with the CI/CD - New updates to default branch workflow, the pr_body_file supplied (if any) should be immutable within the first 8 lines, i.e., no check boxes or similar in the first 8 lines. Indeed, it is recommended to not supply a pr_body_file in this case. Expectations \u00b6 There are no expectations of the repo when using this workflow. Inputs \u00b6 Name Descriptions Required Default Type git_username A git username (used to set the 'user.name' config option). Yes string git_email A git user's email address (used to set the 'user.email' config option). Yes string permanent_dependencies_branch The branch name for the permanent dependency updates branch. No ci/dependency-updates string default_repo_branch The branch name of the repository's default branch. More specifically, the branch the PR should target. No main string pr_body_file Relative path to PR body file from the root of the repository. Example: '.github/utils/pr_body_update_deps.txt' . No Empty string string pr_labels A comma separated list of strings of GitHub labels to use for the created PR. No Empty string string extra_to_dos A multi-line string (insert \\n to create line breaks) with extra 'to do' checks. Should start with - [ ] . No Empty string string update_pre-commit Whether or not to update pre-commit hooks as part of creating the PR. No false boolean python_version The Python version to use for the workflow. Note : This is only relevant if update_pre-commit is true . No 3.9 string install_extras Any extras to install from the local repository through 'pip'. Must be encapsulated in square parentheses ( [] ) and be separated by commas ( , ) without any spaces. Example: '[dev,pre-commit]' . Note : This is only relevant if update_pre-commit is true . No Empty string string skip_pre-commit_hooks A comma-separated list of pre-commit hook IDs to skip when running pre-commit after updating hooks. Note : This is only relevant if update_pre-commit is true . No Empty string string Secrets \u00b6 Name Descriptions Required PAT A personal access token (PAT) with rights to update the permanent_dependencies_branch . This will fallback on GITHUB_TOKEN . No Usage example \u00b6 The following is an example of how a workflow may look that calls CI - Update dependencies PR . It is meant to be complete as is. name : CI - Update dependencies on : schedule : - cron : \"30 6 * * 3\" workflow_dispatch : jobs : check-dependencies : name : Call external workflow uses : CasperWA/ci-cd/.github/workflows/ci_update_dependencies.yml@main if : github.repository_owner == 'CasperWA' inputs : git_username : \"Casper Welzel Andersen\" git_email : \"CasperWA@github.com\" permanent_dependencies_branch : \"ci/dependency-updates\" default_repo_branch : stable pr_labels : \"CI/CD\" extra_to_dos : \"- [ ] Make sure the PR is **squash** merged, with a sensible commit message.\\n- [ ] Check related `requirements*.txt` files are updated accordingly.\" update_pre-commit : true python_version : \"3.9\" install_extras : \"[pre-commit]\" skip_pre-commit_hooks : \"pylint,pylint-models\" secrets : PAT : ${{ secrets.PAT }}","title":"CI - Update dependencies PR"},{"location":"workflows/ci_update_dependencies/#ci-update-dependencies-pr-ci_update_dependenciesyml","text":"This workflow creates a PR if there are any updates in the permanent_dependencies_branch branch that have not been included in the default_repo_branch branch. This workflow works nicely together with the CI - Check pyproject.toml dependencies workflow, and the same value for permanent_dependencies_branch should be used. In this way, this workflow can be called on a schedule to update the dependencies that have been merged into the permanent_dependencies_branch branch into the default_repo_branch branch. The main point of having this workflow is to have a single PR, which can be squash merged, to merge several dependency updates performed by Dependabot or similar. As a \"bonus\" this workflow supports updating pre-commit hooks. Warning If a PAT is not passed through for the PAT secret and GITHUB_TOKEN is used, beware that any other CI/CD jobs that run for, e.g., pull request events, may not run since GITHUB_TOKEN -generated PRs are designed to not start more workflows to avoid escalation. Hence, if it is important to run CI/CD workflows for pull requests, consider passing a PAT as a secret to this workflow represented by the PAT secret. Important If this is to be used together with the CI/CD - New updates to default branch workflow, the pr_body_file supplied (if any) should be immutable within the first 8 lines, i.e., no check boxes or similar in the first 8 lines. Indeed, it is recommended to not supply a pr_body_file in this case.","title":"CI - Update dependencies PR (ci_update_dependencies.yml)"},{"location":"workflows/ci_update_dependencies/#expectations","text":"There are no expectations of the repo when using this workflow.","title":"Expectations"},{"location":"workflows/ci_update_dependencies/#inputs","text":"Name Descriptions Required Default Type git_username A git username (used to set the 'user.name' config option). Yes string git_email A git user's email address (used to set the 'user.email' config option). Yes string permanent_dependencies_branch The branch name for the permanent dependency updates branch. No ci/dependency-updates string default_repo_branch The branch name of the repository's default branch. More specifically, the branch the PR should target. No main string pr_body_file Relative path to PR body file from the root of the repository. Example: '.github/utils/pr_body_update_deps.txt' . No Empty string string pr_labels A comma separated list of strings of GitHub labels to use for the created PR. No Empty string string extra_to_dos A multi-line string (insert \\n to create line breaks) with extra 'to do' checks. Should start with - [ ] . No Empty string string update_pre-commit Whether or not to update pre-commit hooks as part of creating the PR. No false boolean python_version The Python version to use for the workflow. Note : This is only relevant if update_pre-commit is true . No 3.9 string install_extras Any extras to install from the local repository through 'pip'. Must be encapsulated in square parentheses ( [] ) and be separated by commas ( , ) without any spaces. Example: '[dev,pre-commit]' . Note : This is only relevant if update_pre-commit is true . No Empty string string skip_pre-commit_hooks A comma-separated list of pre-commit hook IDs to skip when running pre-commit after updating hooks. Note : This is only relevant if update_pre-commit is true . No Empty string string","title":"Inputs"},{"location":"workflows/ci_update_dependencies/#secrets","text":"Name Descriptions Required PAT A personal access token (PAT) with rights to update the permanent_dependencies_branch . This will fallback on GITHUB_TOKEN . No","title":"Secrets"},{"location":"workflows/ci_update_dependencies/#usage-example","text":"The following is an example of how a workflow may look that calls CI - Update dependencies PR . It is meant to be complete as is. name : CI - Update dependencies on : schedule : - cron : \"30 6 * * 3\" workflow_dispatch : jobs : check-dependencies : name : Call external workflow uses : CasperWA/ci-cd/.github/workflows/ci_update_dependencies.yml@main if : github.repository_owner == 'CasperWA' inputs : git_username : \"Casper Welzel Andersen\" git_email : \"CasperWA@github.com\" permanent_dependencies_branch : \"ci/dependency-updates\" default_repo_branch : stable pr_labels : \"CI/CD\" extra_to_dos : \"- [ ] Make sure the PR is **squash** merged, with a sensible commit message.\\n- [ ] Check related `requirements*.txt` files are updated accordingly.\" update_pre-commit : true python_version : \"3.9\" install_extras : \"[pre-commit]\" skip_pre-commit_hooks : \"pylint,pylint-models\" secrets : PAT : ${{ secrets.PAT }}","title":"Usage example"}]}